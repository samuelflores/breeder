src/Breed.cpp:           std::cout<<__FILE__<<":"<<__LINE__<<" About to call mysql to retrieve a random sequence "<<std::endl;
src/Breed.cpp:        /*int Breed::getNumSequencesInDatabase (std::string sequence, DBManager & mysqlConnection) {
src/Breed.cpp:                std::cout<<__FILE__<<":"<<__LINE__<<" Looking for any existing sequences identical to "<<sequence<<" with jobID "<<mysqlConnection.getJobID()<<std::endl;
src/Breed.cpp:		std::string numSequencesQuery = " select count(*) from results where sequence = \"";
src/Breed.cpp:		numSequencesQuery += sequence;
src/Breed.cpp:                        std::cout<<__FILE__<<":"<<__LINE__<<" Looking for any existing sequences identical to "<<myChromosome.getSequences()<<" AND mutationString identical to "<<myChromosome.getMutationString()<<" AND with jobID "<<mysqlConnection.getJobID()<<std::endl;
src/Breed.cpp:			std::string numSequencesQuery = "select count(*) from results where sequence = \"";
src/Breed.cpp:		wildTypeBiopolymerClassContainer.loadSequencesFromPdb(mysqlConnection.getAlternateRenumberedStructureFile(), bool(false),"",true, true ); // read in sequences from last.1.pdb
src/Breed.cpp:				std::cout<<__FILE__<<":"<<__LINE__<<" About to select first sequence at random from database .. Using index1 : "<<myIndex1<<std::endl;
src/Breed.cpp:				std::cout<<__FILE__<<":"<<__LINE__<<" About to select second sequence at random from database .. Using index2 : "<<myIndex2<<std::endl;
src/Breed.cpp:				std::cout<<__FILE__<<":"<<__LINE__<<" About to select first sequence at random from database .."<<std::endl;
src/Breed.cpp:				std::cout<<__FILE__<<":"<<__LINE__<<" About to select second sequence at random from database .."<<std::endl;
src/Breed.cpp: 				std::cout<<__FILE__<<":"<<__LINE__<<" randomParentSequence1 = "<<randomParentSequence1<<", which is the same as the wild type sequence! Cannot continue."<<std::endl; continue;
src/Breed.cpp: 				std::cout<<__FILE__<<":"<<__LINE__<<" randomParentSequence2 = "<<randomParentSequence2<<", which is the same as the wild type sequence! Cannot continue."<<std::endl; continue;
src/Breed.cpp:                        if (randomParentSequence1.compare(randomParentSequence2) == 0) {std::cout<<__FILE__<<":"<<__LINE__<<" The two sequences : "<<randomParentSequence1<<" and "<<randomParentSequence2<<" are equal! Will not cross these two."<<std::endl; continue;} else
src/Breed.cpp:                        {std::cout<<__FILE__<<":"<<__LINE__<<" The two sequences : "<<randomParentSequence1<<" and "<<randomParentSequence2<<" are different -- it's OK to continue"<<std::endl; }
src/Breed.cpp:			if      ((newChromosome.getSequences()).compare(randomParentSequence1) == 0) {std::cout<<__FILE__<<":"<<__LINE__<<" parentSequence1 and child sequence are identical! Cannot continue with submission"<<std::endl; continue; }
src/Breed.cpp:			else if ((newChromosome.getSequences()).compare(randomParentSequence2) == 0) {std::cout<<__FILE__<<":"<<__LINE__<<" parentSequence2 and child sequence are identical! Cannot continue with submission"<<std::endl; continue; }
src/Breed.cpp:                            std::cout<<__FILE__<<":"<<__LINE__<<" The number of sequences like "<< newChromosome.getSequences()  <<" already in the database is not zero! We cannot submit this job."<<std::endl; 
src/Breed.cpp:                        else {std::cout<<__FILE__<<":"<<__LINE__<<" The number of sequences like "<< newChromosome.getSequences()  <<" already in the database is exactly zero.  Continuing with job submission .."<<std::endl;}
src/Breed.cpp:                // We are no longer using sequencesString's.  Let's just simplify and restrict to mutationString's.
src/Breed.cpp:                    std::cout << __FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" You have specified -SEQUENCE . So we will only update the sequence table with the information for this PDB ID. No calculation will be done.  Exiting without error."<< std::endl; return 0; }
src/Breed.cpp:                // We are no longer using sequencesString's.  Let's just simplify and restrict to mutationString's.
src/Breed.cpp:		    std::cout<<__FILE__<<":"<<__LINE__<<" Unable to open sequence list file: "<<     listFileName<<std::endl;
src/Breed.cpp:		    std::cout<<__FILE__<<":"<<__LINE__<<" Succeeded in opening sequence list file: "<<     listFileName<<std::endl;
src/Breed.cpp:                if (myListTypeEnum == sequencesString) 
src/Breed.cpp:                    std::cout<<__FILE__<<":"<<__LINE__<< " myListTypeEnum == sequencesString is no longer supported. Now we only support 'residues' and 'mutationString'."<<std::endl; exit(1);
src/Breed.cpp:			std::cout<<__FILE__<<":"<<__LINE__<<" Read sequence from file : >"<<inputLine<<"<"<<std::endl;
src/Breed.cpp:				if (myListTypeEnum == sequencesString) {
src/Breed.cpp:					newChromosome = Chromosome(modifiedInputLine, 0, wildTypeBiopolymerClassContainer); // modifiedInputLine is a sequencesString.  maxMutations shouldn't matter since we're running from a list.
src/Breed.cpp:					std::cout<<__FILE__<<":"<<__LINE__<<" The number of sequences like "<< newChromosome.getSequences()  <<" already in the database is not zero! Going on to the next mutant in the list or loop."<<endl;//We will submit anyway, since the wild type equivalent may not have been run."<<std::endl; 
src/Breed.cpp:				else {std::cout<<__FILE__<<":"<<__LINE__<<" The number of sequences like "<< newChromosome.getSequences()  <<" already in the database is exactly zero.  Continuing with job submission .."<<std::endl;}
src/BreederParameterReader.cpp:   std::cout << " -SEQUENCE                     < no arguments > If invoked (requires no following arguments, just -SEQUENCE), we will only populate the sequence table in the database, and not perform any calculations." << std::endl;
src/BreederParameterReader.cpp:   std::cout << " -L                            <list file name>  Read sequences from the provided file (CR delimited). Deprecated! Not guaranteed to work." << std::endl;
src/BreederParameterReader.cpp:   std::cout << " -FASTAEXECUTABLE              <fasta_lwp.pl with full path> This executable queries NCBI to find PDB IDs based on significance of sequence alignment. Used by homologyScanner, not required by breeder." << std::endl;
src/BreederParameterReader.cpp:   std::cout << " -FASTATEMPDIRECTORY           <directory> fasta_lwp.pl needs a place to write the results of its search. Within this directory, a subdirectory will appear named with the PDB ID of the PrimaryJob.  Under that directory, there will be one further subdirectory for each chain in the provided complex.  Within each of those chain directories there will be files containing information about homologs for that chain. It is best to leave the fasta-pg.ids.txt file so that the search can be skipped on future runs, but the other files can probably be deleted without much consequence." << std::endl;
src/BreederParameterReader.cpp:        breed.loadSequenceTable(*dbConnection); // this loads the "sequence" table with chain IDs, residue numbers, and amino acid types.
src/BreederParameterReader.cpp:            std::cout << __FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" You have requested to set the amino acid sequence only. Skipping the rest of the run. "<<std::endl;
src/BreederParameterReader.cpp:       	if (listFileName.compare("XXXX") != 0) { // if the user specified a listFileName.. proceed to read sequences from list:
src/BreederParameterReader.cpp:		std::cout<<__FILE__<<":"<<__LINE__<<" Detected that you want to read sequences from a file, "<<listFileName<<".  Proceeding to read this .."<<std::endl;
src/BreederParameterReader.cpp:        dbConnection->setSequenceOnly(sequence);
src/BreederParameterReader.cpp:            std::cout << __FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" You have requested to set the amino acid sequence only. Skipping the rest of the database work. "<<std::endl;
src/BreederParameterReader.cpp:        //dbConnection->setSequenceOnly(sequence);
src/BreederParameterReader.cpp:        if (sequence){
src/BreederParameterReader.cpp:            std::cout << __FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" You have requested to set the amino acid sequence only. Skipping the rest of the validation.    "<<std::endl;
src/BreederParameterReader.cpp:                   sequence = 1;                 
src/BreederParameterReader.cpp:	            if (option == "-L")         listTypeEnum = sequencesString;
src/BreederParameterReader.cpp:        listTypeEnum = sequencesString;
src/BreederParameterReader.cpp:        sequence = 0;  
src/BreederParameterReader.cpp.bak:   std::cout << " -L                            <list file name>  Read sequences from the provided file (CR delimited). Deprecated! Not guaranteed to work." << std::endl;
src/BreederParameterReader.cpp.bak:   std::cout << " -FASTAEXECUTABLE              <fasta_lwp.pl with full path> This executable queries NCBI to find PDB IDs based on significance of sequence alignment. Used by homologyScanner, not required by breeder." << std::endl;
src/BreederParameterReader.cpp.bak:   std::cout << " -FASTATEMPDIRECTORY           <directory> fasta_lwp.pl needs a place to write the results of its search. Within this directory, a subdirectory will appear named with the PDB ID of the PrimaryJob.  Under that directory, there will be one further subdirectory for each chain in the provided complex.  Within each of those chain directories there will be files containing information about homologs for that chain. It is best to leave the fasta-pg.ids.txt file so that the search can be skipped on future runs, but the other files can probably be deleted without much consequence." << std::endl;
src/BreederParameterReader.cpp.bak:           	if (listFileName.compare("XXXX") != 0) { // if the user specified a listFileName.. proceed to read sequences from list:
src/BreederParameterReader.cpp.bak:		std::cout<<__FILE__<<":"<<__LINE__<<" Detected that you want to read sequences from a file, "<<listFileName<<".  Proceeding to read this .."<<std::endl;
src/BreederParameterReader.cpp.bak:	            if (option == "-L")         listTypeEnum = sequencesString;
src/BreederParameterReader.cpp.bak:        listTypeEnum = sequencesString;
src/Chromosome.cpp:		//sequence = "";
src/Chromosome.cpp:		sequences = "";
src/Chromosome.cpp:		sequence = newSequence;
src/Chromosome.cpp:		std::cout<<__FILE__<<":"<<__LINE__<<" Parsing "<<newSequences<<". first chain = "<<myChainID<<" with sequence "<<mySequence<<std::endl;
src/Chromosome.cpp:		if ((dotPosition < (sequences.length()-1))  && 
src/Chromosome.cpp:			std::cout<<__FILE__<<":"<<__LINE__<<" The current sequences is of length 0!"<<std::endl; exit(1);}
src/Chromosome.cpp:			std::cout<<__FILE__<<":"<<__LINE__<<" the given sequence strings are different lengths!"<<std::endl; exit (1);
src/Chromosome.cpp:		std::string childString = parentSequence1.substr(0,crossOverPoint) + parentSequence2.substr((crossOverPoint),std::string::npos); // recombine the two sequence strings
src/Chromosome.cpp:			std::cout<<__FILE__<<":"<<__LINE__<<" the child sequence string is of the wrong length!"<<std::endl; exit (1);
src/Chromosome.cpp:		if (parentSequence1.compare(parentSequence2) == 0) {std::cout<<__FILE__<<":"<<__LINE__<<" parent sequences are identical!"<<std::endl; exit(1);}
src/Chromosome.cpp:                if (parentSequence1.length() != parentSequence2.length()) {std::cout<<__FILE__<<":"<<__LINE__<<" The supplied sequences are of lenghts "<<parentSequence1.length()<< " and "<<parentSequence2.length()<<std::endl; exit(1);}
src/Chromosome.cpp:                if (lastSequenceDifferencePosition == 0) {std::cout<<__FILE__<<":"<<__LINE__<<" Error! no sequence difference found!"<<std::endl; exit(1);}
src/Chromosome.cpp:                if ((lastSequenceDifferencePosition - firstSequenceDifferencePosition) <= 0) {std::cout<<__FILE__<<":"<<__LINE__<<" Warning: sequences differ at one position only! Offspring will be identical to one parent."<<std::endl; }
src/Chromosome.cpp:                std::cout<<__FILE__<<":"<<__LINE__<<" Offspring sequences = "<<newSequences<<std::endl;
src/Chromosome.cpp:                std::cout<<__FILE__<<":"<<__LINE__<<" Dont' use this yet .. it's not clear that it works with sequences"<<std::endl; exit(1); /*
src/Chromosome.cpp:		std::cout<<__FILE__<<":"<<__LINE__<<" sequence before mutation at position "<<mutationPosition<<" is: "<< sequences<<std::endl;
src/Chromosome.cpp:		sequence = sequence.substr(0, mutationPosition) + aminoAcidTypes[int(20*rand())] +  sequence.substr(mutationPosition +1 , std::string::npos);
src/Chromosome.cpp:		std::cout<<__FILE__<<":"<<__LINE__<<" sequence after mutation at position "<<mutationPosition<<" is: "<< sequence<<std::endl;*/
src/Chromosome.cpp:		return sequences;
src/Chromosome.cpp:            std:string sequencesString = "";     
src/Chromosome.cpp:                sequencesString += biopolymerClassContainer.getMutationVector()[i].getChain();
src/Chromosome.cpp:                sequencesString += MUTATIONMINORSEPARATOR; // separates chain ID from residueID
src/Chromosome.cpp:                sequencesString +=  mysqlConnection.getPdbResidueIDFromRenumberedResidueNumber( biopolymerClassContainer.getMutationVector()[i].getChain(), biopolymerClassContainer.getMutationVector()[i].getResidue().getResidueNumber()); 
src/Chromosome.cpp:                sequencesString += MUTATIONMINORSEPARATOR; // separates residueID from mutation
src/Chromosome.cpp:                sequencesString += biopolymerClassContainer.updMutationVector()[i].getSubstitutedResidueType();
src/Chromosome.cpp:                    sequencesString += MUTATIONMAJORSEPARATOR ; // connect mutants // was "."
src/Chromosome.cpp:            return sequencesString;
src/Chromosome.cpp:                        std::cout<<__FILE__<<":"<<__LINE__<<" The current sequence is of length 0!"<<std::endl; exit(1);}
src/Chromosome.cpp:                        if (mysqlConnection.getNumSequenceTableEntries()) { // Only try to populate the pdbNumberedMutationString field if there are entries in the sequence table. Later, we will have to figure out why there are no such entries for the children.               
src/Chromosome.cpp:			    startJobString = std::string("insert into results (jobName, pdbId, batch_directory, sequence,mutationString,pdbNumberedMutationString, status,numMutations ) VALUES (\"")    +  mysqlConnection.getJobName()  + "\", \"" +   mysqlConnection.getPdbId()  +  "\",   \""    +  workingDirectory  + std::string("\", \"")  + getSequences() + std::string("\" , \"") + getMutationString() + std::string("\", \"") + getPdbNumberedMutationString(mysqlConnection) +std::string("\" , \"submitted\", ") + std::to_string(numMutations()) + std::string(");");
src/Chromosome.cpp:			    startJobString = std::string("insert into results (jobName, pdbId, batch_directory, sequence,mutationString, status,numMutations ) VALUES (\"")    +  mysqlConnection.getJobName()  + "\", \"" +   mysqlConnection.getPdbId()  +  "\",   \""    +  workingDirectory  + std::string("\", \"")  + getSequences() + std::string("\" , \"") + getMutationString() + std::string("\", \"submitted\", ") + std::to_string(numMutations()) + std::string(");");
src/Chromosome.cpp:                                // Explanation: we expect either all rows to be inserted, or all rows to be unchanged. If any rows are UPDATEd, that means some sequence difference has appeared with respect to the last time this function was called on this protein. This is suspicious and should be checked before going further.  
src/Chromosome.cpp.bak:		//sequence = "";
src/Chromosome.cpp.bak:		sequences = "";
src/Chromosome.cpp.bak:		sequence = newSequence;
src/Chromosome.cpp.bak:		std::cout<<__FILE__<<":"<<__LINE__<<" Parsing "<<newSequences<<". first chain = "<<myChainID<<" with sequence "<<mySequence<<std::endl;
src/Chromosome.cpp.bak:		if ((dotPosition < (sequences.length()-1))  && 
src/Chromosome.cpp.bak:			std::cout<<__FILE__<<":"<<__LINE__<<" The current sequences is of length 0!"<<std::endl; exit(1);}
src/Chromosome.cpp.bak:			std::cout<<__FILE__<<":"<<__LINE__<<" the given sequence strings are different lengths!"<<std::endl; exit (1);
src/Chromosome.cpp.bak:		std::string childString = parentSequence1.substr(0,crossOverPoint) + parentSequence2.substr((crossOverPoint),std::string::npos); // recombine the two sequence strings
src/Chromosome.cpp.bak:			std::cout<<__FILE__<<":"<<__LINE__<<" the child sequence string is of the wrong length!"<<std::endl; exit (1);
src/Chromosome.cpp.bak:		if (parentSequence1.compare(parentSequence2) == 0) {std::cout<<__FILE__<<":"<<__LINE__<<" parent sequences are identical!"<<std::endl; exit(1);}
src/Chromosome.cpp.bak:                if (parentSequence1.length() != parentSequence2.length()) {std::cout<<__FILE__<<":"<<__LINE__<<" The supplied sequences are of lenghts "<<parentSequence1.length()<< " and "<<parentSequence2.length()<<std::endl; exit(1);}
src/Chromosome.cpp.bak:                if (lastSequenceDifferencePosition == 0) {std::cout<<__FILE__<<":"<<__LINE__<<" Error! no sequence difference found!"<<std::endl; exit(1);}
src/Chromosome.cpp.bak:                if ((lastSequenceDifferencePosition - firstSequenceDifferencePosition) <= 0) {std::cout<<__FILE__<<":"<<__LINE__<<" Warning: sequences differ at one position only! Offspring will be identical to one parent."<<std::endl; }
src/Chromosome.cpp.bak:                std::cout<<__FILE__<<":"<<__LINE__<<" Offspring sequences = "<<newSequences<<std::endl;
src/Chromosome.cpp.bak:                std::cout<<__FILE__<<":"<<__LINE__<<" Dont' use this yet .. it's not clear that it works with sequences"<<std::endl; exit(1); /*
src/Chromosome.cpp.bak:		std::cout<<__FILE__<<":"<<__LINE__<<" sequence before mutation at position "<<mutationPosition<<" is: "<< sequences<<std::endl;
src/Chromosome.cpp.bak:		sequence = sequence.substr(0, mutationPosition) + aminoAcidTypes[int(20*rand())] +  sequence.substr(mutationPosition +1 , std::string::npos);
src/Chromosome.cpp.bak:		std::cout<<__FILE__<<":"<<__LINE__<<" sequence after mutation at position "<<mutationPosition<<" is: "<< sequence<<std::endl;*/
src/Chromosome.cpp.bak:		return sequences;
src/Chromosome.cpp.bak:                        std::cout<<__FILE__<<":"<<__LINE__<<" The current sequence is of length 0!"<<std::endl; exit(1);}
src/Chromosome.cpp.bak:			//std::string startJobString = std::string("insert into results (jobName, batch_directory, sequence,mutationString, status,numMutations ) VALUES (\"")    +  mysqlConnection.getJobName()  + std::string("\", \"")    +  workingDirectory  + std::string("\", \"")  + getSequences() + std::string("\" , \"") + getMutationString() + std::string("\", \"submitted\", ") + boost::lexical_cast<std::string>(numMutations()) + std::string(");");
src/Chromosome.cpp.bak:			std::string startJobString = std::string("insert into results (jobName, pdbId, batch_directory, sequence,mutationString, status,numMutations ) VALUES (\"")    +  mysqlConnection.getJobName()  + "\", \"" +   mysqlConnection.getPdbId()  +  "\",   \""    +  workingDirectory  + std::string("\", \"")  + getSequences() + std::string("\" , \"") + getMutationString() + std::string("\", \"submitted\", ") + std::to_string(numMutations()) + std::string(");");
src/Chromosome.cpp.bak:                                // Explanation: we expect either all rows to be inserted, or all rows to be unchanged. If any rows are UPDATEd, that means some sequence difference has appeared with respect to the last time this function was called on this protein. This is suspicious and should be checked before going further.  
src/DBManager.cpp:        std::string sequenceTableSelectionString = " where renumberedResidueNumber = " + to_string(renumberedResidueNumber) + " and pdbId = '" + getPdbId() + "' and chainId = '" + myChainId + "' ";
src/DBManager.cpp:        std::string residueNumberQueryString = " select (pdbResidueNumber) from sequence " + sequenceTableSelectionString + " ; ";
src/DBManager.cpp:        std::string insertionCodeQueryString = " select (insertionCode) from sequence " + sequenceTableSelectionString + " ; ";
src/DBManager.cpp:        std::string sequenceTableSelectionString = " where  pdbId = '" + getPdbId() + "'  ";
src/DBManager.cpp:        std::string query = " select count(*) from sequence " + sequenceTableSelectionString + " ; ";
src/DBManager.cpp:         string myInsertQueryString = "insert into sequence (pdbId, chainId, renumberedResidueNumber, pdbResidueNumber, insertionCode, aminoAcidType) VALUES ( '" + getPdbId() + "' , '" + myChainId + "' , " + std::to_string(myRenumberedResidueNumber)  + " , " + std::to_string(myPdbResidueNumber) + " , '" + std::string(1,myInsertionCode) + "' , '" + myAminoAcidType + "') ; "; 
src/DBManager.cpp:         std::string myCountQueryString = "select count(*) from sequence where " + selectionString + " ; ";
src/DBManager.cpp:             std::cout << __FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " counted " << myCount << " entries in sequence table. This is OK. Will proceed with insertion operation." << std::endl; 
src/DBManager.cpp:             string myInsertQueryString = "insert into sequence (pdbId, chainId, renumberedResidueNumber, pdbResidueNumber, insertionCode, aminoAcidType) VALUES ( '" + getPdbId() + "' , '" + myChainId + "' , " + std::to_string(myRenumberedResidueNumber)  + " , " + std::to_string(myPdbResidueNumber) + " , '" + std::string(1,myInsertionCode) + "' , '" + myAminoAcidType + "') ; "; 
src/DBManager.cpp:         else if (myCount == 1) { std::cout << __FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Counted " << myCount << " entries in sequence table. This is OK. Will proceed with update operation."<<std::endl; 
src/DBManager.cpp:             std::string myCountQueryString2 = "select count(*) from sequence where " + selectionString + " and " + selectionString2 + " ; ";
src/DBManager.cpp:                 string myUpdateQueryString = "update sequence set pdbResidueNumber = " + std::to_string(myPdbResidueNumber) + " ,  insertionCode =  '" + std::string(1,myInsertionCode) + "', aminoAcidType = '" + myAminoAcidType + "' where " + selectionString + " ; "; 
src/DBManager.cpp:         else if (myCount > 1) { std::cout << __FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Counted " << myCount << " entries in sequence table. This is NOT OK. Exiting now."<<std::endl; exit(1);}
src/DBManager.cpp:          std::string myQueryString0 = "select sequenceIdentity from matchingChains " +  matchingChainsSelectionString ( pdbPrimary, pdbHomolog , chainPrimary,chainHomolog );
src/DBManager.cpp:    // Determine if the chainwise sequence identity is high enough. sequenceIdentityCutoff should be in the range 0.0 to 100.0
src/DBManager.cpp:    bool DBManager::chainSequenceAlignmentIsSatisfactory(std::string pdbPrimary, std::string pdbHomolog , std::string chainPrimary, std::string chainHomolog, double sequenceIdentityCutoff ){
src/DBManager.cpp:      std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" for primary pdbId : "<<pdbPrimary <<" , homolog pdb ID  >"<<pdbHomolog<<"< chainPrimary =  >"<<chainPrimary<<"< , chainHomolog =  >"<< chainHomolog <<"< .. determining whether sequence alignment is satisfactory.." <<std::endl; 
src/DBManager.cpp:          double mySequenceIdentity = getMatchingChainsValueAsDouble(pdbPrimary, pdbHomolog, chainPrimary, chainHomolog,"sequenceIdentity");
src/DBManager.cpp:          //sequenceIdentityIsNull = matchingChainsValueIsNull(pdbPrimary, pdbHomolog, chainPrimary, chainHomolog,"sequenceIdentity");
src/DBManager.cpp:          if (mySequenceIdentity >= sequenceIdentityCutoff){
src/DBManager.cpp:               std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" sequence identity = "<<mySequenceIdentity<<", which is at or over the cutoff of "<<sequenceIdentityCutoff<<". This is satisfactory. Returning True."<<std::endl;   
src/DBManager.cpp:          //} elsif(matchingChainsValueIsNull(pdbPrimary, pdbHomolog, chainPrimary, chainHomolog,"sequenceIdentity")) {
src/DBManager.cpp:               std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" sequence identity = "<<mySequenceIdentity<<", which is UNDER the cutoff of "<<sequenceIdentityCutoff<<". This is notsatisfactory. Returning False."<<std::endl;   
src/DBManager.cpp:    // Determine if the chainwise sequence identity is Null.
src/DBManager.cpp:    /*bool DBManager::chainSequenceAlignmentIsNull        (std::string pdbPrimary, std::string pdbHomolog , std::string chainPrimary, std::string chainHomolog, double sequenceIdentityCutoff){
src/DBManager.cpp:      std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" for primary pdbId : "<<pdbPrimary <<" , homolog pdb ID  >"<<pdbHomolog<<"< chainPrimary =  >"<<chainPrimary<<"< , chainHomolog =  >"<< chainHomolog <<"< .. determining whether sequence alignment is satisfactory.." <<std::endl; 
src/DBManager.cpp:          bool   mySequenceIdentityIsNull = getMatchingChainsValueAsDoubleReturnsNull(pdbPrimary, pdbHomolog, chainPrimary, chainHomolog,"sequenceIdentity");
src/DBManager.cpp:          if (mySequenceIdentity >= sequenceIdentityCutoff){
src/DBManager.cpp:               std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" sequence identity = "<<mySequenceIdentity<<", which is at or over the cutoff of "<<sequenceIdentityCutoff<<". This is satisfactory. Returning True."<<std::endl;   
src/DBManager.cpp:               std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" sequence identity = "<<mySequenceIdentity<<", which is UNDER the cutoff of "<<sequenceIdentityCutoff<<". This is notsatisfactory. Returning False."<<std::endl;   
src/DBManager.cpp:		std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" Just retrieved wild type sequence for job "<<runID<<" , it's : "<<myWildTypeSequence<<std::endl;
src/DBManager.cpp:        // Retrieves a sequence at random for breeding.  Note that we make sure foldx_energy is available.
src/DBManager.cpp:				retrievedSequence = queryValueAsString ("  select sequence from results where " + jobIDAndPdbIdSelectionString()  + " and not ISNULL(foldx_energy) order by RAND() limit 1 ; ");
src/DBManager.cpp: 			std::string retrievedSequenceFoldxEnergyQuery = std::string("  select (foldx_energy - foldx_energy_wild_type) from results where ") + jobIDAndPdbIdSelectionString() + std::string(" and sequence = \"") + retrievedSequence + std::string("\" ; ") ;
src/DBManager.cpp:                std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" Having found an acceptable sequence : "<<retrievedSequence<<", we are moving on .."<<std::endl;
src/DBManager.cpp:		queryStream<<std::string("select sequence ")<<queryStreamCore.str()<<" order by "<<orderField<<" "<<order<<" limit "<<index<<" , 1 ; ";
src/DBManager.cpp:		//std::string retrievedSequenceFoldxEnergyQuery = std::string("  select (foldx_energy - foldx_energy_wild_type) from results where jobName = \"")+ getJobID()  + std::string("\" and sequence = \"") + retrievedSequence + std::string("\" ; ") ;
src/DBManager.cpp:                std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" Having found an acceptable sequence : "<<retrievedSequence<<", we are moving on .."<<std::endl;
include/Breed.h:		sequencesString,// The user will provide a list of mutant sequences.  We are not using this much anymore.
include/Breed.h:        //int getNumSequencesInDatabase (std::string sequence, DBManager & mysqlConnection);  
include/BreederParameterReader.h:	bool          sequence;
include/BreederParameterReader.h:	//myListTypeEnum = sequencesString;
include/Chromosome.h:	//std::string sequence;
include/Chromosome.h:	std::string sequences;
include/Command.h.bak:	string	sequence1;
include/Command.h.bak:	string	sequence2;
include/Command.h.bak:	string	sequence3;
include/Command.h.bak:	string	sequence4;
include/DBManager.h:                bool        sequenceOnly;
include/DBManager.h:                void   setSequenceOnly(const bool mySequenceOnly) {sequenceOnly = mySequenceOnly;}
include/DBManager.h:		    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Returning "<<sequenceOnly<<std::endl;  
include/DBManager.h:		    return sequenceOnly ;}
include/DBManager.h:                // Accessors for local sequence identity
include/DBManager.h:                bool   chainSequenceAlignmentIsSatisfactory(std::string pdbPrimary, std::string pdbHomolog , std::string chainPrimary, std::string chainHomolog, double sequenceIdentityCutoff );
